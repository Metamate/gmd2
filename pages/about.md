# Game Development 2

## Code

XR-GMD2

## ECTS

5

## Prerequisites

The student must be familiar with:

- Object-oriented programming basics

## Purpose

The course introduces the student to engine-level game programming using a low-level game framework. The student learns by implementing classic video games, gaining direct control over essential systems like game loop, rendering, asset pipeline and game physics. The purpose is to teach software engineering in a game context, including architecture, design patterns, decoupling, component systems and data-driven design.

## Learning Outcomes

### Knowledge

The student will be able to:

- Explain the structure of a traditional game engine (game loop, update/draw pipeline).
- Identify recurring design patterns in games (e.g. state, observer, command).
- Describe common game architecture solutions (e.g. component systems, services, state machines).
- Explain collision detection, tile-based level systems, and input handling.
- Identify performance bottlenecks in game code.

### Skills

The student will be able to:

- Implement a complete game loop using a low-level game framework.
- Apply core object-oriented design principles to design robust, flexible, and maintainable game systems.
- Implement common game-specific design patterns to solve recurring design problems in gameplay programming.
- Implement scenes, UI systems, input systems, entity systems, collision detection, and basic game physics.
- Implement serialization for simple save/load systems.
- Refactor game code for readability, maintainability, and extensibility.
- Use debugging and profiling tools effectively.

### Competences

The student will be able to:

- Produce a playable vertical slice for a game with a well-structured internal architecture.
- Document software designs using visual notation, such as UML class diagrams, to effectively communicate architectural decisions.
- Critically analyze and evaluate the structure of an existing game project and propose design improvements based on established principles.
- Demonstrate an understanding of the trade-offs between different architectural choices (e.g., performance vs. flexibility).

## Topics

Game Architecture, Software Design Principles & Patterns, Game Loop, Rendering, Input Handling, Asset Pipeline, Collision Detection, Game Physics, Tilemaps, Serialization, Component-Based Design, Finite State Machines, Service Locator, Observer, Command, Prototype, Object Pooling, Spatial Partitioning, Data-Driven Design, Optimization.

## Teaching methods and study activities

12 sessions (48 lessons). Lessons consist of discussion of theory and exercises, as well as project work. The total workload of the student is expected to be around 140 hours. The course includes one course project.

## Exam

Exam prerequisites:

1. Attendance (â‰¥ 75%)

Type of exam:
Individual oral exam, 20 minutes, without preparation.
The student will draw from a pool of known questions and is expected to reference their course project as part of the answer. This involves analyzing source code, as well as potentially writing or modifying source code during the exam. The final grade will be based on an overall assessment of the project presented and the oral examination. Internal assessment.

Tools allowed:
All

Re-exam:
Same as the ordinary exam.

## Grading criteria

Grading based on the Danish 7-point scale.

## Course Responsible

Jakob Trigger Knop (JKNR)

## Valid From

01.02.2026

## Course type

Compulsory for Software Engineering XR, 2. semester
