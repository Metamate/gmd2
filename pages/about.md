# About The Course

Some meta-text about the course and teachers.

## Course description

The course introduces students to engine-level game programming using the MonoGame framework. Unlike Unity, MonoGame requires explicit control over rendering, game loops, asset pipelines, collision, scenes, and architecture. The focus is on teaching software engineering in a game context: architecture, design patterns, decoupling, component design, testing, and data-driven systems.

[todo: reword "engine level"?]

### Learning Outcomes

#### Knowledge

Students can:

- Explain the structure of a traditional game engine (game loop, update/draw pipeline).
- Describe common game architecture patterns (component systems, managers, services, state machines).
- Explain collision detection, tile-based level systems, and input handling.
- Identify performance bottlenecks in C# game code.
- Describe Git workflows suitable for code-heavy projects.

#### Skills

Students can:

- Implement a complete game loop using MonoGame.
- Architect systems using separation of concerns and design patterns.
- Implement scenes, UI systems, input systems, entity systems, collision detection, and basic physics.
- Refactor game code for readability, maintainability, and extensibility.
- Implement serialization for simple save/load systems.
- Use debugging and profiling tools effectively.

#### Competences

Students can:

- Work in small game development teams using Git, branching, merging, and reviews.
- Produce a playable vertical slice with a well-structured internal architecture.
- Document design decisions and system architecture.
- Reflect on engineering challenges in a short postmortem.

### Topics

Software Design Principles, Architectural Patterns, and Design Patterns in the context of game development. [TODO: add game engine context, and oop-concepts]

---

Upon successful completion of the course, the student will be able to:

Analyze and Evaluate: Critically analyze and evaluate the structure of an existing MonoGame project and propose design improvements based on established principles.

Apply Principles: Apply core Object-Oriented Design (OOD) principles (e.g., SOLID) and game programming patterns (e.g., Component-Based Architecture, State Machines) to design robust, flexible, and maintainable game systems.

Implement Architecture: Implement a clear software architecture for a 2D MonoGame project, demonstrating an understanding of the trade-offs between different architectural choices (e.g., performance vs. flexibility).

Utilize Patterns: Identify and implement common C# and game-specific design patterns (e.g., Factory, Observer, Command) to solve recurring design problems in gameplay programming.

Document and Communicate: Document software designs using visual notation, such as UML Class Diagrams and Component Diagrams, to effectively communicate architectural decisions.
