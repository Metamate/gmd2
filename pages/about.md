# Course Description

The course introduces students to engine-level game programming using a low-level framework. Students gain direct control over essential systems like game loop, rendering, asset pipeline, collisions, physics and more. The focus is on teaching software engineering in a game context, including architecture, design patterns, decoupling, component systems and data-driven design.

## Learning Outcomes

### Knowledge

Students can:

- Explain the structure of a traditional game engine (game loop, update/draw pipeline).
- Identify recurring design patterns in games (e.g. state, observer, command).
- Describe common game architecture solutions (e.g. component systems, services, state machines).
- Explain collision detection, tile-based level systems, and input handling.
- Identify performance bottlenecks in game code.

### Skills

Students can:

- Implement a complete game loop using a simple game framework.
- Apply core object-oriented design principles to design robust, flexible, and maintainable game systems.
- Implement common game-specific design patterns to solve recurring design problems in gameplay programming.
- Implement scenes, UI systems, input systems, entity systems, collision detection, and basic physics.
- Implement serialization for simple save/load systems.
- Refactor game code for readability, maintainability, and extensibility.
- Use debugging and profiling tools effectively.

### Competences

Students can:

- Produce a playable vertical slice for a game with a well-structured internal architecture.
- Document software designs using visual notation, such as UML Class Diagrams, to effectively communicate architectural decisions.
- Critically analyze and evaluate the structure of an existing game project and propose design improvements based on established principles.
- Demonstrate an understanding of the trade-offs between different architectural choices (e.g., performance vs. flexibility).

## Topics

Game Architecture, Software Design Principles & Patterns, Game Loop, Rendering, Input Handling, Asset Management, Collision Detection, Physics, Tilemaps, Serialization, Component-Based Design, Finite State Machines, Service Locator, Observer, Command, Prototype, Object Pooling, Spatial Partitioning, Data-Driven Design, Optimization.
