# Course Description

## Course Title

Game Development 2 (SPL2)

## ECTS

5

## Prerequisites

The student must be familiar with:
- Object Oriented Programming basics 

## Purpose

The course introduces students to engine-level game programming using a low-level framework. Students learn by implementing classic video games, gaining direct control over essential systems like game loop, rendering, asset pipeline, collisions and physics. The purpose is to teach software engineering in a game context, including architecture, design patterns, decoupling, component systems and data-driven design.

## Learning Outcomes

### Knowledge

Students can:

- Explain the structure of a traditional game engine (game loop, update/draw pipeline).
- Identify recurring design patterns in games (e.g. state, observer, command).
- Describe common game architecture solutions (e.g. component systems, services, state machines).
- Explain collision detection, tile-based level systems, and input handling.
- Identify performance bottlenecks in game code.

### Skills

Students can:

- Implement a complete game loop using a simple game framework.
- Apply core object-oriented design principles to design robust, flexible, and maintainable game systems.
- Implement common game-specific design patterns to solve recurring design problems in gameplay programming.
- Implement scenes, UI systems, input systems, entity systems, collision detection, and basic physics.
- Implement serialization for simple save/load systems.
- Refactor game code for readability, maintainability, and extensibility.
- Use debugging and profiling tools effectively.

### Competences

Students can:

- Produce a playable vertical slice for a game with a well-structured internal architecture.
- Document software designs using visual notation, such as UML class diagrams, to effectively communicate architectural decisions.
- Critically analyze and evaluate the structure of an existing game project and propose design improvements based on established principles.
- Demonstrate an understanding of the trade-offs between different architectural choices (e.g., performance vs. flexibility).

## Topics

Game Architecture, Software Design Principles & Patterns, Game Loop, Rendering, Input Handling, Asset Management, Collision Detection, Physics, Tilemaps, Serialization, Component-Based Design, Finite State Machines, Service Locator, Observer, Command, Prototype, Object Pooling, Spatial Partitioning, Data-Driven Design, Optimization.

## Teaching methods and study activities

12 sessions (48 lessons). These lessons consist of discussion of theory and exercises. The total workload of the 
student is expected to be around 140 hours. 
The course will include one course project. 

## Exam

Exam prerequisites: 
1. Attendance (â‰¥ 75%) 

Type of exam:
Individual oral exam, 20 minutes, without preparation. 
The student will draw from a pool of known questions and is expected to reference their course project as part of 
the answer. This involves demonstrating and potentially writing or modifying source code during the exam. 
The final grade will be based on an overall assessment of the project presented and the oral examination. 
Internal assessment. 

Tools allowed:
All

Re-exam: 
Same as the ordinary exam. 

## Grading criteria 

Grading based on the Danish 7-point scale.

## Course Responsible

Jakob Trigger Knop (JKNR)